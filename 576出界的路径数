#这个一开始没做出来 参照的网上的一个解法
class Solution:
    def findPaths(self, m: int, n: int, N: int, i: int, j: int) -> int:
        tmp = [[[0 for i in range(n)] for j in range(m)] for k in range(N+1)]
        for k in range(1,N+1):
            for p in range(m):
                for q in range(n):
                    if 0 == p:
                        up = 1
                    else:
                        up = tmp[k-1][p-1][q]
                    if m-1 == p:
                        down = 1
                    else:
                        down = tmp[k-1][p+1][q]
                    if 0 == q:
                        left = 1
                    else:
                        left = tmp[k-1][p][q-1]
                    if n-1 == q:
                        right = 1
                    else:
                        right = tmp[k-1][p][q+1]
                    tmp[k][p][q] = (up+down+left+right)%1000000007
        return tmp[N][i][j]

#这个解法用时和占内存都算不上好，但是由于我能看懂#-#
#有一个问题就是AC的解法好像都没有考虑球到边缘并不出界反而是往回走几步再出界的情况
#然后就是这个题总觉得没能够太理解，所以也没有po一些更好的算法上来
